\chapter{Grid-Based Simulations}
\label{chapter grid}

This chapter introduces a grid-based multiphase fluid simulation scheme and its CUDA implementation in this project. This scheme has three key components: a \textbf{MAC} (Marker and Cell) grid for discretizing the Euler equations, a \textbf{FLIP} (Fluid Implicit Particle) algorithm for advection, and a Jacobi linear solver for solving the diffusion equation and the Poisson pressure equation (which ensures incompressibility).

\section{Operator Splitting}

A common way for numerically solving differential equations is the \textit{splitting} approach. As a simple example, consider the simple differential equation:
$$
\frac{dx}{dt} = f(x)+g(x) ~~~~\mbox{With boundary condition $x(0)=x_0$}
$$
To numerically solve this, decide on some small time step $\triangle t$, and let $x_{[n]}$ be the value of $x$ at the $n$th time step. The goal is to find $x_{[n]}$ for increasing larger $n$. To do this, start with $x_{[0]}=x_0$ and consider the two differential equations:
\begin{equation*}
    \begin{aligned}
        \frac{dx}{dt} = f(x)\\
        \frac{dx}{dt} = g(x)
    \end{aligned}
\end{equation*}
Suppose there exists some good solutions (either analytical or numerical) for these two equations, then these solutions can be used to find a good solution for the original equation. Specifically, suppose $F_{f_0}(t)$ is a solution of $\dfrac{dx}{dt} = f(x)$ with boundary condition $x(0)=f_0$, and $G_{g_0}(t)$ is a solution of $\dfrac{dx}{dt} = g(x)$ with boundary condition $x(0)=g_0$, then, the original equation can be solved as 
\begin{equation*}
    \begin{aligned}
        \widetilde{x} = F_{x_{[n]}}(\triangle t) \\
        x_{[n+1]} = G_{\widetilde{x}}(\triangle t) \\
    \end{aligned}
\end{equation*}
In essence, this approach splits the equation into a few more easily solved differential equations, and accumulates the solution of each over a small time step. 

This same splitting approach can be applied to the Euler equations. To do so, the Euler momentum equation is first written in a form where the material derivative is expanded using equation (\ref{Du/Dt}):
$$
\frac{\partial \textbf{u}}{\partial t}   =  -\begin{pmatrix}
    \nabla \textbf{u}_x  \cdot \textbf{u}\\
     \nabla \textbf{u}_y \cdot \textbf{u}\\
     \nabla \textbf{u}_z \cdot \textbf{u}
  \end{pmatrix}
  + \textbf{g}
  -\frac{\nabla p}{\rho} 
$$
This then allows the equation, and therefore the simulation algorithm, to be split into three parts:
\begin{enumerate}
    \item The equation
    $$
    \frac{\partial \textbf{u}}{\partial t}   =  -\begin{pmatrix}
        \nabla \textbf{u}_x  \cdot \textbf{u}\\
         \nabla \textbf{u}_y \cdot \textbf{u}\\
         \nabla \textbf{u}_z \cdot \textbf{u}\end{pmatrix} 
    $$
    Again using equation (\ref{Du/Dt}), this can be rewritten back into the material derivative form:
    $$
    \dfrac{D\textbf{u}}{Dt} = 0
    $$
    Intuitively, solving this equation means to move the fluid according to its velocity field, in a way such that the velocity of each infinitesimal fluid partial remains unchanged. This is the step known as \textit{advection}. 

    \item The equation
    $$
    \frac{\partial \textbf{u}}{\partial t}   = \textbf{g}
    $$
    Solving this equation is the process of exerting external forces (e.g gravity) on the fluid, straightforwardly achievable by adding $\triangle t\textbf{g}$ to velocity field output by the advection step.

    \item The equation
    $$
    \frac{\partial \textbf{u}}{\partial t}   = -\frac{\nabla p}{\rho} 
    $$
    Importantly, since this is the last step of the splitting, it is essential to make sure that the results of solving this equation satisfies the incompressibility condition $\nabla \cdot \textbf{u} = 0$. This amounts to finding a pressure field $p$ such that, subtracting by $\triangle t \dfrac{\nabla p}{\rho}$ makes the velocity have zero divergence. This step enforces the incompressibility of the fluid.

\end{enumerate}



\section{Discretization}
Throughout the simulation, a discretized representation of the velocity is needed. A obvious choice is to maintain a 2D grid, with each grid cell storing a vector quantity that is the velocity sampled at the center of the grid cell. This projects implements a slightly more sophisticated method, known as the \textbf{MAC}(Marker and Cell) grid, which offers more convenience and higher accuracy when computing the divergence $\nabla \cdot \textbf{u}$ during the incompressibility step.

Instead of storing the value of $\textbf{u} = (\textbf{u}_x,\textbf{u}_y,\textbf{u}_z)$ sampled at the cell center, an MAC grid stores different components of $\textbf{u}$ sampled at different locations. Specifically, the grid cell at position $(x,y,z)$ stores the value of $\textbf{u}_x$ sampled at the center of its left face, it stores the value of $\textbf{u}_y$ sampled at its lower face, and it stores the value of $\textbf{u}_z$ sampled at its back face, as illustrated in this figure:

\begin{figure}[!h]
    \centering
        \begin{tikzpicture} 

            \newcommand{\sizef}{4}
            \newcommand{\halff}{2}

            \draw[dashed,->] (0,0,0) -- (\sizef + 1,0,0) node[right] {+x};
            \draw[dashed,->] (0,0,0) -- (0,\sizef + 1,0) node[above] {+y};
            \draw[dashed,->] (0,0,0) -- (0,0,\sizef + 1) node[below] {+z};


            \foreach \a in {0,1}{
                \foreach \b in {0,1}{
                    \ifthenelse{  \a  = 0 \AND \b = 0  }
                    {
                        \draw[dashed] (\a * \sizef,\b * \sizef,0) 
                        -- (\a * \sizef,\b * \sizef,\sizef);

                        \draw[dashed] (\a * \sizef,0,\b * \sizef) 
                            -- (\a * \sizef,\sizef,\b * \sizef);

                        \draw[dashed] (0,\a * \sizef,\b * \sizef) 
                            -- (\sizef,\a * \sizef,\b * \sizef);
                    }
                    {

                        \draw (\a * \sizef,\b * \sizef,0) 
                        -- (\a * \sizef,\b * \sizef,\sizef);

                        \draw (\a * \sizef,0,\b * \sizef) 
                            -- (\a * \sizef,\sizef,\b * \sizef);

                        \draw (0,\a * \sizef,\b * \sizef) 
                            -- (\sizef,\a * \sizef,\b * \sizef);
                    }

                }
            }

            

            \node[draw,circle, fill, inner sep=1] at (\halff,\halff,0){};
            \node[below] at (\halff,\halff,0){\large{$\textbf{u}_{x,y,z-\frac{1}{2}}$}};

           

            \node[draw,circle, fill, inner sep=1] at (\halff,0,\halff){};
            \node[below] at (\halff,0,\halff){\large{$\textbf{u}_{x,y-\frac{1}{2},z}$}};

            
            \node[draw,circle, fill, inner sep=1] at (0,\halff,\halff){};
            \node[below] at (0,\halff,\halff){\large{$\textbf{u}_{x-\frac{1}{2},y,z}$}};
           
        

            % \node[draw,circle, fill, inner sep=1] at (\halff,\halff,\sizef){};
            % \node[right] at (\halff,\halff,\sizef){\large{$\textbf{u}_{x,y,z+\frac{1}{2}}$}};

            % \node[draw,circle, fill, inner sep=1] at (\halff,\sizef,\halff){};
            % \node[above] at (\halff,\sizef,\halff){\large{$\textbf{u}_{x,y+\frac{1}{2},z}$}};

            % \node[draw,circle, fill, inner sep=1] at (\sizef,\halff,\halff){};
            % \node[right] at (\sizef,\halff,\halff){\large{$\textbf{u}_{x+\frac{1}{2},y,z}$}};

        
         \end{tikzpicture}
    
    \caption{a 2D MAC grid cell and the velocity data it stores}
    \label{mac cell 1}
\end{figure}


The quantities $\textbf{u}_{x,y,z-\frac{1}{2}}$, $\textbf{u}_{x,y-\frac{1}{2},z}$, $\textbf{u}_{x-\frac{1}{2},y,z}$ are all scalars, representing the velocity pointing at the $x$, $y$, and $z$ direction, respectively. Furthermore, notice that the values of $\textbf{u}_{x+\frac{1}{2},y,z}$, $\textbf{u}_{x,y+\frac{1}{2},z}$, and $\textbf{u}_{x,y,z+\frac{1}{2}}$, which are respectively sampled at the right, upper, and front faces, will also be available. This is because $\textbf{u}_{x+\frac{1}{2},y,z} = \textbf{u}_{x+1-\frac{1}{2},y,z}$, that is, the value of $\textbf{u}_x$ sampled at the right face of the cell is exactly the value of $\textbf{u}_x$ sampled at the neighboring cell to the right. The same can be applied for the upper and front faces. As a result, there are 6 velocity values associated with each grid cell:

\begin{figure}[]
    \centering
        \begin{tikzpicture} 

            \newcommand{\sizef}{4}
            \newcommand{\halff}{2}

            \draw[dashed,->] (0,0,0) -- (\sizef + 1,0,0) node[right] {+x};
            \draw[dashed,->] (0,0,0) -- (0,\sizef + 1,0) node[above] {+y};
            \draw[dashed,->] (0,0,0) -- (0,0,\sizef + 1) node[below] {+z};


            \foreach \a in {0,1}{
                \foreach \b in {0,1}{
                    \ifthenelse{  \a  = 0 \AND \b = 0  }
                    {
                        \draw[dashed] (\a * \sizef,\b * \sizef,0) 
                        -- (\a * \sizef,\b * \sizef,\sizef);

                        \draw[dashed] (\a * \sizef,0,\b * \sizef) 
                            -- (\a * \sizef,\sizef,\b * \sizef);

                        \draw[dashed] (0,\a * \sizef,\b * \sizef) 
                            -- (\sizef,\a * \sizef,\b * \sizef);
                    }
                    {

                        \draw (\a * \sizef,\b * \sizef,0) 
                        -- (\a * \sizef,\b * \sizef,\sizef);

                        \draw (\a * \sizef,0,\b * \sizef) 
                            -- (\a * \sizef,\sizef,\b * \sizef);

                        \draw (0,\a * \sizef,\b * \sizef) 
                            -- (\sizef,\a * \sizef,\b * \sizef);
                    }

                }
            }

            \node[draw,circle, fill, inner sep=1] at (\halff,\halff,0){};
            \node[below] at (\halff,\halff,0){\large{$\textbf{u}_{x,y,z-\frac{1}{2}}$}};

           

            \node[draw,circle, fill, inner sep=1] at (\halff,0,\halff){};
            \node[below] at (\halff,0,\halff){\large{$\textbf{u}_{x,y-\frac{1}{2},z}$}};

            
            \node[draw,circle, fill, inner sep=1] at (0,\halff,\halff){};
            \node[below] at (0,\halff,\halff){\large{$\textbf{u}_{x-\frac{1}{2},y,z}$}};

            
            \node[draw,circle, fill, inner sep=1] at (\halff,\halff,\sizef){};
            \node[right] at (\halff,\halff,\sizef){\large{$\textbf{u}_{x,y,z+\frac{1}{2}}$}};

            \node[draw,circle, fill, inner sep=1] at (\halff,\sizef,\halff){};
            \node[above] at (\halff,\sizef,\halff){\large{$\textbf{u}_{x,y+\frac{1}{2},z}$}};

            \node[draw,circle, fill, inner sep=1] at (\sizef,\halff,\halff){};
            \node[right] at (\sizef,\halff,\halff){\large{$\textbf{u}_{x+\frac{1}{2},y,z}$}};

        
         \end{tikzpicture}
    
    \label{mac cell 2}
\end{figure}

Using these quantities, a finite difference approximation of the value of the divergence of the velocity, $\nabla \cdot \textbf{u}$, can be easily computed:
\begin{equation}
    \begin{aligned}
        \nabla \cdot \textbf{u} 
        &=
        \frac{\partial \textbf{u}_x}{\partial x} +  
        \frac{\partial \textbf{u}_y}{\partial y} +
        \frac{\partial \textbf{u}_z}{\partial z} \\
        &\approx 
        \frac{\triangle \textbf{u}_x}{\triangle x} +  
        \frac{\triangle \textbf{u}_y}{\triangle y} +
        \frac{\triangle \textbf{u}_z}{\triangle z}\\
        &= 
        \frac{\textbf{u}_{x+\frac{1}{2},y,z} - \textbf{u}_{x-\frac{1}{2},y,z}}{\triangle x} +  
        \frac{\textbf{u}_{x,y+\frac{1}{2},z} - \textbf{u}_{x,y-\frac{1}{2},z}}{\triangle x} +
        \frac{\textbf{u}_{x,y,z+\frac{1}{2}} - \textbf{u}_{x,y,z-\frac{1}{2}}}{\triangle x}
    \end{aligned}
\end{equation}

In the MAC grid, only the velocity field is stored in this pattern. Other scaler quantities, such as pressure, are all sampled at the center of each grid cell. This arrangement offers a convenient discretization of the equation $\dfrac{\partial \textbf{u}}{\partial t}   = -\dfrac{\nabla p}{\rho}$, used in step 3 of the simulation.



